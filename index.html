<!DOCTYPE html>
<html lang="ch">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme-color" content=#58b77a>
  <title>ROBIN-3910</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="rob-曾洛镔">
  <meta name="keywords" content="">
  <meta name="description" content="rob的个人博客网站，记录编码/学习/生活日常">
  <script id="hexo-configurations">
  var CONFIG = {
    root: '/',
    theme: 'lx',
    version: '0.3.9',
    localsearch: {
      "enable": 'false',
      "trigger": "auto",
      "top_n_per_article": "1",
      "unescape": 'false',
      "preload": 'false'
    },
    path: '-'
  };
</script>

  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/css/main.min.css">
  <style type="text/css">
    pre,
    code {
      font-family: 'Fira Code', monospace;
    }
    html {
      font-family: sans-serif;
    }
    body {
      font-family: sans-serif;
    }
    h1, h2, h3, h4, h5, figure {
      font-family: sans-serif;
    }
    .menu-container{
      font-family: sans-serif;
    }
  </style>

  <script src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/js/jquery.jside.menu.js"></script>
	<script>
	$(document).ready(function(){
	$(".menu-container").jSideMenu({
	    jSidePosition: "position-right",
	    jSideSticky: true,
	    jSideSkin: "greenish",
	     });
	}); 
	</script>
  
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
<meta name="generator" content="Hexo 5.4.0"></head>
<body>
<div id="page">

<div id="lx-aside" style="background-image: url(//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/images/cover.jpeg)">
  <div class="overlay">
  <div class="featured">
    <div class="avatar"><a href="/"><img style="width: 100px;height: 100px;" src="/images/avatar.jpeg"></a></div>
    <span>rob-曾洛镔</span>
    <h1>ROBIN-3910</h1>
    <span>——今天大刀🗡没带过来，就不砍你需求了</span>
    <div class="social-links">
    <a href="https://github.com/Robin3910" target="_blank"><i class="fa fa-github fa-fw"></i></a>
    <a href="robin3910@163.com" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
</div>
  </div>
  </div>
</div>

<div id="lx-main-content">
  <div class="lx-post"> 

  <div class="lx-entry padding">
    <div>
      <h2 class="title"><a href="/2021/05/07/viewport/">移动端适配总结</a></h2>
      <span class="lx-post-detail"><i class="fa fa-calendar-o"></i> 2021-05-07</span>
      <p><p>如果下面这行代码经常见到，但又对其一知半解，那么这篇文章也许可以帮你解惑</p>
<p><meta name="viewport" content="width=device-width, initial-scale="1.0""></meta name="viewport" content="width=device-width,></p>
<p>一、基础知识梳理<br>1、像素<br>a.物理像素<br>物理像素也就是移动设备中所提到的分辨率，比如手机的分辨率为750x1334像素，其指的是屏幕的垂直方向上有1334个物理像素块，水平方向上有750个像素块。其分辨率越高，所展示的图像就越清晰。</p>
<p>b.设备独立像素(device-independent pixels)/CSS像素<br>设备的独立像素，不同于物理像素，更多指的是设计稿中的尺寸，比如设计稿中一个Img的宽高为100x100像素，这个就是独立像素，也对应于css像素，是虚拟化的.</p>
<p>那么，可能会有疑问，这手机分辨率有750x1334像素，但是屏幕大小只有375x667像素，这两者有什么关系呢？</p>
<p>这里就需要引入css像素，也就是设备独立像素。css像素中1px可以代表多个物理像素，在dpr为2的手机中，CSS1px可以对应2个物理像素，也就是相比于分辨率为375x667的手机来说，750x1334分辨率的手机会更加清晰细腻。</p>
<p>如下图所示：这是dpr=2的情况，最外框为css的1px，但其却覆盖了4个物理像素（蓝色的小方块）</p>
<p>当用户缩小时：物理像素（蓝色小方块）是不会改变的，此时一个物理像素从原来只覆盖1/4的CSS像素变成了可覆盖大于7/10的CSS像素，相当于一个物理像素所能展示的CSS像素更多，所以用户所能看到的内容也更多，但图像变小</p>
<p>反之，当用户放大时：原来一个CSS像素仅需要4个物理像素便能展示，放大后一个CSS像素所需的物理像素可能要8-9个（大概），所以能展示的CSS像素变少，图像变大，用户所能看到的内容也就变少了</p>
<p>2、设备像素比dpr<br>dpr=物理像素/独立像素，通过js可以获取：window.devicesPixelRatio。</p>
<p>二、视口viewport<br>PC与移动端的视口viewport<br>PC端视口<br>在html、body设置width:100%;height:100%;的时候，它并不是无效的。100%这种百分数应该是继承父元素而来的。那在这里是继承哪里的呢？</p>
<p>在PC浏览器中，有一个用来约束CSS布局视口的东西，又叫做初始包含块。这也就是所有宽高继承的由来。除去margin、padding，浏览器布局视口layout viewport和可视窗口visual viewport宽高是一致的，统称为视口viewport，同时也和浏览器本身的宽度一致。</p>
<p>举个例子：下图中，当前浏览器的宽度1365px，则相应的body宽度也为1365px，文字显示正常，阅读无障碍</p>
<p>通过document.documentElement.clientWidth可以获取布局视口。</p>
<p>移动端<br>布局视口</p>
<p>在移动端，默认的情况下，移动端浏览器厂商为了让用户在小屏幕下传统的PC网页也能够很好地展示，一般会把布局视口宽度设置地很大去存放页面，在768px ~ 1024px之间，最常见的宽度是980px。这个宽度可以通过document.documentElement.clientWidth得到。</p>
<p>视觉视口</p>
<p>对于视觉视口来说，这个东西是呈现给用户的，它是用户看到网页区域内CSS像素的数量。（CSS像素的数量越多，说明展示的页面元素越多，看到的页面元素也就越小）</p>
<p>值得注意的是，在移动端缩放不会改变布局视口的宽度，当缩小的时候，屏幕覆盖的css像素变多，视觉视口变大，看到的字体图形字体变小，反之亦然。</p>
<p>而在PC端，缩放对应布局宽度和视觉窗口宽度都是联动的。而浏览器宽度本身是固定的，无论怎么缩放都不受影响。</p>
<p>视口缺陷<br>从上图可以看到，用户手机屏幕所展示的内容（visual viewport）仅占了layout viewport的一部分，并不能全部展示出来。</p>
<p>通过chrome模拟出手机的屏幕</p>
<p>如上图所示，布局视口的宽度（这里body被默认设置成了980px）是要远远大于移动端浏览器的宽度(360px)的。大多数浏览器会默认铺开整个布局视口到整个屏幕中，导致页面中的字体非常小，阅读体验非常差。</p>
<p>试想一下，如果一个网页不对移动端进行适配，用户进行阅读的时候，由于字体太小，就不得不手动放大以便于阅读，但是放大的时候另外一个问题又出现了：</p>
<p>从上图中可以看到，虽然文字变大了，但是相应的，屏幕中所显示的信息也变少了，用户需要手动去滑动整个页面让目标信息展示出来。</p>
<p>(这个二维码阅读体验极差，可以扫码体验一下)</p>
<p>此时，我们可以通过<meta name="viewport" content="width=360">来设置layout viewport的宽度为360，此时，body的大小变成了360px，字体大小为14px，显而易见，body为360px下显示14px的字体和body为980px下显示14px的字体，肯定前者显示更加友好</meta name="viewport" content="width=360"></p>
<p>（扫我吧，我字贼大：）</p>
<p>理想视口<br>所以后来苹果引入了理想视口的概念，它对设备来说是最理想的布局视口尺寸，用户进入页面时就不需要手动再去缩放页面。</p>
<p>所以便有了这段代码：</p>
<p><meta name="viewport" content="width=device-width, initial-scale="1.0""></meta name="viewport" content="width=device-width,></p>
<p>width=device-width： 把布局视口设置成为浏览器（屏幕）的宽度。</p>
<p>initial-scale=1 ：初始缩放的比例是1，使用它的时候，同时也会将布局视口的尺寸设置为初始缩放比例后的尺寸。而缩放的尺寸就是基于屏幕的宽度来的，也就起到了和width=device-width同样的效果。</p>
<p>每个移动设备浏览器中都有一个理想的宽度，这个理想的宽度是指css中的宽度，跟设备的物理宽度没有关系，在css中，这个宽度就相当于100%的所代表的那个宽度（这个其实就是devices-width）。</p>
<p>我们可以用meta标签把viewport的宽度设为那个理想的宽度，如果不知道这个设备的理想宽度是多少，那么用device-width这个特殊值就行了，同时initial-scale=1也有把viewport的宽度设为理想宽度的作用。</p>
<p>为什么需要有理想的viewport呢？比如一个分辨率为320x480的手机理想layout viewport的宽度是320px，而另一个屏幕尺寸相同但分辨率为640x960的手机的理想layout viewport宽度也是为320px，那为什么分辨率大的这个手机的理想宽度要跟分辨率小的那个手机的理想宽度一样呢？</p>
<p>这是因为，只有这样才能保证同样的网站在不同分辨率的设备上看起来都是一样或差不多的。实际上，现在市面上虽然有那么多不同种类不同品牌不同分辨率的手机，但它们的理想viewport宽度归纳起来无非也就 320、360、384、400等几种，都是非常接近的，理想宽度的相近也就意味着我们针对某个设备的理想viewport而做出的网站，在其他设备上的表现也不会相差非常多甚至是表现一样的。</p>
<p>三、移动端适配方案<br>在移动端上，有了layout viewport的固定宽度之后，再进行移动端适配就不再是难事，简单总结了如下几种移动端适配的方法：</p>
<p>1、flex弹性盒模型实现的移动端适配<br>以淘宝移动端页面为例：<a target="_blank" rel="noopener" href="https://main.m.taobao.com/index.html">https://main.m.taobao.com/index.html</a></p>
<p>通过将盒子设置成flex布局以及width:100%，根据需要来设置justify-content以及align-items来对齐居中等，实现在不同屏幕尺寸的移动端下的适配。</p>
<p>在需要适配的地方使用弹性盒模型以及百分比，在不需要适配的地方使用px，举个例子，底部tap就是适配的，而中间的导航，如”天猫新品，今日爆款“的图标块是原始px尺寸</p>
<p>这种适配方案在手机端是OK的，但一旦转换到ipad端….，如下图所示，中间的导航栏由于div宽度过长，而其中的图标大小还是原始尺寸，导致盒子过大，图标无法填充满整个盒子，更别说是切换分页了（这个盒子中是有分页器的）</p>
<p>这种适配方案的优缺点：</p>
<p>优点：<br>实现简单便捷，flex+百分比/flex+vw灵活方便，无需引入其他库便可以实现大部分手机的屏幕适配<br>缺点：<br>针对于平板类的移动端，还需要另外做适配才能兼容，比较繁琐<br>2、rem+px2rem适配方案</p>
<blockquote>
<p>在W3C官网上是这样描述rem的——“font size of the root element” 。<br>基本思路：</p>
</blockquote>
<p>假如说我们的设计稿为750px，现在把设计稿分成10份，一份就为75px。</p>
<p>同样，获取到移动端屏幕的宽度，将其分成十份，并且将每份的大小设置成1rem，也就是设置html的font-size。设置div大小时，便可用rem进行设置，比如，设计稿中一个Img是75 x 75，代码中就可以设置这个img为1rem，即img的宽度是设计稿的1/10，对应的比例在手机中也就是屏幕宽度的1/10，也就是1rem。分成几份全由自己来决定，可以分成10份，也可以分成20份，等等。</p>
<p>这样可以实现适配，但是问题在于，每次写css的宽高时，都需要通过自己再进行计算转换成rem，比如如果有个img是50x50像素，它在设计稿中的比例是 50/75 = 0.667份，相当于在代码中我们需要写0.667rem，这其实是非常繁琐且低效的。</p>
<p>但是，现有工具可以帮我们解决这个问题：postcss-px2rem。我们在写代码的时候还是可以用px，设计稿中写了多少px我们代码中就写多少px，在代码编译阶段，postcss-px2rem就会将px编译成相应的rem，这样我们就无需手动去换算，这是一种比较成熟的移动端适配方案。（这里不深入探究1px的问题，解决1px问题需要配合scale以及dpr进行）</p>
<p>下面以vue项目且750px设计稿为例：</p>
<p>我们设定设计稿html的fontSize = 75px，则1rem = 75px(分成10份)，体现在postCss-px2rem中就是remUnit: 75。这时在代码中写1px，代码编译后会转换成 1/75 = 0.01333rem，而这个0.01333rem是相对于移动端屏幕的，</p>
<p>举个例子：如果移动端屏幕为375px，且我们对移动端网页的html设置了fontSize = 375 / 10 = 37.5px，则0.013333rem = 37.5 * 0.013333 = 0.5px，其比例和设计稿是一致的，所以显示在屏幕中也就是正常的。</p>
<p>设置font-size的代码如下（引入的方式按需而定，比如这段代码可以通过一个script标签内联在app.html）：</p>
<p>const width = document.documentElement.clientWidth;<br>const html = document.getElementByTagName(‘html’)[0];<br>html.style.fontSize = width / 10 + ‘px’;</p>
<p>配置postCss-px2rem：</p>
<p>// postcss.config.js<br>module.exports = {<br>plugins: {<br>autoprefixer: {},<br>‘postcss-px2rem’: {<br>remUnit: 75<br>}<br>}<br>};</p>
<p>3、vw+px2rem适配方案<br>在移动端适配发展的初期，浏览器对vw的兼容性相比于rem是差很多的，但是随着浏览器的发展，慢慢地对vw的兼容相比于以前有了天翻地覆的变化</p>
<p>回想rem适配，若是将设计稿分成100份的时候，其实1rem也就对应了1vw，两者的原理是差不多的，vw的好处就体现在其不再需要引入js，直接通过css代码便可以设置，</p>
<p>代码如下：</p>
<p>其中，还是将设计稿分成了十份，如果设计稿为1080px，则一份为108像素，注意，这两个值是通过自己去设置的，并不是一定要这样设置，可以根据设计稿以及自己方便计算来设置；</p>
<p>设计稿的html fontSize设计成1/10的设计稿宽度108，所以postCss-px2rem中的remUnit就为108，相应的移动端页面中1rem = 10vw，相当于在375的屏幕中1rem = 37.5px。</p>
<p>同时，也可以利用px2rem工具，写代码时就可以直接利用px。</p>
<p>参考文章：</p>
<p>viewport</p>
<p><a target="_blank" rel="noopener" href="https://www.quirksmode.org/mobile/viewports.html">https://www.quirksmode.org/mobile/viewports.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.quirksmode.org/mobile/viewports2.html">https://www.quirksmode.org/mobile/viewports2.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.quirksmode.org/mobile/metaviewport/">https://www.quirksmode.org/mobile/metaviewport/</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/2050/p/3877280.html">https://www.cnblogs.com/2050/p/3877280.html</a></p>
<p>移动端适配：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/amfe/article/issues/17">https://github.com/amfe/article/issues/17</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/entry/5a9d07ee6fb9a028c149f55b">https://juejin.im/entry/5a9d07ee6fb9a028c149f55b</a></p>
</p>
      <div class="post-button"><a class="btn" href="/2021/05/07/viewport/" rel="noopener"><i class="fa fa-angle-double-right fa-fw"></i>Read More</a></div>
    </div>
  </div>
  <div class="lx-entry padding">
    <div>
      <h2 class="title"><a href="/2021/05/07/okr-record/">OKR阅读心得</a></h2>
      <span class="lx-post-detail"><i class="fa fa-calendar-o"></i> 2021-05-07</span>
      <p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>OKR全称是<strong>Objective and key results</strong>，目标与<strong>关键结果法</strong>。</p>
<p>它关注目标，是一套定义和跟踪目标及其完成情况的管理工具和方法。目标是指你想完成什么事情；关键结果是确认你是否做到了这件事情，即关键结果是对于目标实现的量化。</p>
<p>作者杜尔自己多年来使用OKR，还在不同规模和性质的企业和组织中推广OKR。他在本书里介绍了如何使用OKR，实现增长。他还邀请包括比尔·盖茨等在内的OKR的实践者。</p>
<p>以第一人称的方式，讲述自己使用OKR的故事，通过生动的案例，展示OKR的力量。</p>
<h3 id="OKR与KPI"><a href="#OKR与KPI" class="headerlink" title="OKR与KPI"></a>OKR与KPI</h3><p>其实一说到绩效考核，大家可能马上就会想起KPI，也就是关键绩效指标。这两个工具的区别在哪儿呢？最直接的区别是，KPI有明确的考核指标，跟奖金激励挂钩，但是OKR更侧重目标管理，</p>
<p>跟升职加薪没有直接关系。KPI是一种压力管理方法，能让你为了完成考核指标而埋头工作，但你有可能只顾得上完成指标，而不管实际效果。OKR则是一种愿景管理方法，让你工作时不会偏离方向，取得实实在在的进步。</p>
<h3 id="OKR特点"><a href="#OKR特点" class="headerlink" title="OKR特点"></a>OKR特点</h3><p>关于OKR的一些特点：</p>
<h4 id="在设定”OKR”上："><a href="#在设定”OKR”上：" class="headerlink" title="在设定”OKR”上："></a>在设定”OKR”上：</h4><ul>
<li>要使目标具有使命感，意义感；</li>
<li>重要且具体，以结果导向</li>
<li>关键结果明确，有时间节点</li>
<li>具有挑战性</li>
</ul>
<h4 id="OKR的四大利器："><a href="#OKR的四大利器：" class="headerlink" title="OKR的四大利器："></a>OKR的四大利器：</h4><ul>
<li>让整个组织聚焦在重要的事情上</li>
<li>对责任进行追踪</li>
<li>促进团队的协同</li>
<li>挑战不可能</li>
</ul>
<h4 id="OKR的使用："><a href="#OKR的使用：" class="headerlink" title="OKR的使用："></a>OKR的使用：</h4><p>​    <u>围绕CFR展开（comversation, feedback, recognition）沟通、反馈、评价</u></p>
<p>C：沟通 - 不断围绕一个时间段内的OKR进行沟通，最终达成共识</p>
<p>F：反馈 - 根据OKR的进行进度不断反馈，追踪OKR的进展</p>
<p>R：评价 - 对OKR的关键结果完成情况评价，打分并总结。</p>
<h3 id="阅读《OKR》的心得体会："><a href="#阅读《OKR》的心得体会：" class="headerlink" title="阅读《OKR》的心得体会："></a>阅读《OKR》的心得体会：</h3><p>制定目标的过程应该极为小心，不可让目标太容易实现，也不可让目标过于宏达导致在规定的时间内无法实现而产生懈怠，所以目标的制定是OKR的难点之一。<br>所制定的目标必须具有挑战性，而不是日常反复的工作，是需要走出舒适区才能实现的目标。</p>
<p>要小心区别重要事件和紧急事件，很多容易先做紧急事件，而不紧急的重要事件一直被排在后面而导致最终没办法完成既定的目标。其实工作中很多这样的场景，<br>业务需求频繁导致需要把精力大部分放置于业务需求当中，于我目前而言，是好事，刚接手这一工作，最重要的就是熟悉业务，而熟悉业务最简单的方式就是<br>多做需求。但是实现业务需求对个人的提升是有瓶颈的，可能一两年后，如果没有补充自己的知识面，深究技术原理，仅停留在实现功能层面上的话，便很难再有提升。<br>所以，要合理分配精力，对业务需求保质保量，同时通过对重要事件的完成，提升自己，反向推动提升工作效率，两者相辅相成。</p>
<p>书中还有关于OKR的一点我觉得十分有价值，就是OKR是相当透明的，公司上下之间目标明确，每个人都可以看到任何人的OKR，一线人员可以不断调整自己的OKR与<br>公司OKR对齐，通过自己OKR的实现，来推动公司的OKR；而同事与同事之间也能相互了解对方正在做什么事情，相互配合，互相促进。这其实是共赢的，公司有提升，职员也有提升。</p>
</p>
      <div class="post-button"><a class="btn" href="/2021/05/07/okr-record/" rel="noopener"><i class="fa fa-angle-double-right fa-fw"></i>Read More</a></div>
    </div>
  </div>
  <div class="lx-entry padding">
    <div>
      <h2 class="title"><a href="/2021/05/07/ts-notes/">ts随笔</a></h2>
      <span class="lx-post-detail"><i class="fa fa-calendar-o"></i> 2021-05-07</span>
      <p><pre><code>该笔记主要记录了一些编码过程中比较常见但是又容易模糊的知识点
</code></pre>
<p><strong>原始类型</strong>：string, boolean, number, null, void, symbol, undefined, bigint</p>
<p>Tip: 编码过程中也有类似的关键字Boolean, Number, String等，这是JS的构造函数，和类型完全不同。</p>
<p><strong>Bigint</strong></p>
<p>使用Bigint可以安全地存储和操作大整数，即这个数已经超过了JS构造函数Number能够表示的安全整数范围，使用Bigint需要使用ESnext编译辅助库。</p>
<p>下面两段代码就可以看出区别：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> max = <span class="built_in">Number</span>.MAX_SAFE_INTEGER; <span class="comment">// 2^53-1</span></span><br><span class="line"><span class="keyword">const</span> max1 = max + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> max2 = max + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(max1 === max2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> max = <span class="built_in">BigInt</span>(<span class="built_in">Number</span>.MAX_SAFE_INTEGER); <span class="comment">// 2^53-1</span></span><br><span class="line"><span class="keyword">const</span> max1 = max + <span class="number">1n</span>;</span><br><span class="line"><span class="keyword">const</span> max2 = max + <span class="number">2n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(max1 === max2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>





<p><strong>unknown和any</strong></p>
<p>unknown是更安全的any类型，any类型在赋值之前，可以通过.去获取属性和方法不会抛错，但是unknown会。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: <span class="built_in">any</span>;</span><br><span class="line">value.foo.bar; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> zoo: unknown;</span><br><span class="line">zoo.foo; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>









<p><strong>元组</strong></p>
<p>元组与数组非常相似，元组可以说是类型更加严格的数组。</p>
<p>元组定义完后可以通过push添加元素，但是获取时会报错</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">x = [<span class="string">&quot;robin&quot;</span>, <span class="number">10</span>]; <span class="comment">// ok</span></span><br><span class="line">x = [<span class="number">10</span>]; <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">x.push(<span class="number">2</span>);</span><br><span class="line">x[<span class="number">2</span>]; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>







<p><strong>枚举的本质</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direction&#123;</span><br><span class="line">		up,</span><br><span class="line">		left,</span><br><span class="line">		down,</span><br><span class="line">		right</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Direction.up) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(Direction[<span class="number">0</span>]) <span class="comment">// up</span></span><br></pre></td></tr></table></figure>

<p>从上述例子中可以看出枚举中实现了正反向同时映射，平常的例子中，一般都是正向映射，比如一个对象，key =&gt; value；</p>
<p>直接看看枚举编译后的JS代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Direction;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Direction</span>) </span>&#123;</span><br><span class="line">		Direction[Direction[<span class="string">&#x27;up&#x27;</span>] = <span class="number">0</span>] = <span class="string">&#x27;up&#x27;</span>;</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">&#125;) (Direction || (Direction = &#123;&#125;));</span><br></pre></td></tr></table></figure>





<p><strong>实现一个完善的pick函数，用于获取对象中的value</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> KVObject &#123;</span><br><span class="line">    [key: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">o: T, names: <span class="built_in">Array</span>&lt;K&gt;</span>): <span class="title">Array</span>&lt;<span class="title">T</span>[<span class="title">K</span>]&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> names.map(<span class="function">(<span class="params">n: K</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o[n];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj: KVObject = &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;robin&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">25</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pick(obj, [<span class="string">&quot;username&quot;</span>, <span class="string">&#x27;age&#x27;</span>]));</span><br></pre></td></tr></table></figure>



<p><strong>把接口中的成员变成可选，这个场景十份常见，我们在声明一个接口后，常常在声明变量的时候去利用这个接口，但是在声明变量时，变量内的属性或者方法一时半会又给不到，这时候利用以下这个方法就可以有效兼容</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="built_in">string</span>;</span><br><span class="line">    id: <span class="built_in">number</span>;</span><br><span class="line">    token: <span class="built_in">string</span>;</span><br><span class="line">    avatar: <span class="built_in">string</span>;</span><br><span class="line">    role: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> partial&lt;T&gt; = &#123; [K <span class="keyword">in</span> keyof T]? : T[K] &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user: partial&lt;User&gt; = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<p><strong>类型编程：编写一个工具类型将interface中函数类型的名称取出来</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Part &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    subParts: Part[];</span><br><span class="line">    updatePart(newName: <span class="built_in">string</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FunctionPropName&lt;T&gt; = &#123;[K <span class="keyword">in</span> keyof T]: T[K] <span class="keyword">extends</span> <span class="built_in">Function</span> ? K: <span class="built_in">never</span>&#125;[keyof T];</span><br><span class="line"><span class="keyword">type</span> funcName = FunctionPropName&lt;Part&gt;; <span class="comment">// type funcName = &#x27;updatePart&#x27;</span></span><br></pre></td></tr></table></figure>





<p><strong>类型编程：取出下面interface中的可选类型（利用空对象进行扩展甄别，网上看到的一种方法，很巧妙）</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> People &#123;</span><br><span class="line">    <span class="keyword">readonly</span> n: <span class="built_in">number</span>;</span><br><span class="line">    id: <span class="built_in">string</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">from</span>?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OptionalKeys&lt;T&gt; = &#123;[K <span class="keyword">in</span> keyof T]-?: (&#123;&#125; <span class="keyword">extends</span> &#123;[P <span class="keyword">in</span> K]: T[P]&#125; ? K : <span class="built_in">never</span>)&#125;[keyof T];</span><br><span class="line"><span class="keyword">type</span> r = OptionalKeys&lt;People&gt;; <span class="comment">// &#x27;age&#x27;|&#x27;from&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须属性</span></span><br><span class="line"><span class="keyword">type</span> RequiredKeys&lt;T&gt; = &#123;[K <span class="keyword">in</span> keyof T]-?: (&#123;&#125; <span class="keyword">extends</span> &#123;[P <span class="keyword">in</span> K]: T[P]&#125; ? <span class="built_in">never</span> : K)&#125;[keyof T];</span><br></pre></td></tr></table></figure>
</p>
      <div class="post-button"><a class="btn" href="/2021/05/07/ts-notes/" rel="noopener"><i class="fa fa-angle-double-right fa-fw"></i>Read More</a></div>
    </div>
  </div>
  <div class="lx-entry padding">
    <div>
      <h2 class="title"><a href="/2021/05/07/h5-bg-animation/">H5背景动效实现方案总结</a></h2>
      <span class="lx-post-detail"><i class="fa fa-calendar-o"></i> 2021-05-07</span>
      <p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通常来说，一个元素，动往往比静更能吸引用户眼球。针对于H5页面的背景，炫酷的背景动画特效能定向助力传播和品牌打造。本文将介绍几种常见的H5中背景动效的制作手法。</p>
<h2 id="一、GIF"><a href="#一、GIF" class="headerlink" title="一、GIF"></a>一、GIF</h2><p>gif图片擅长于制作循环的小动画，使用gif有以下几个条件：</p>
<pre><code>1. 动画是循环的，首尾相接
2. 每次循环的时间必须要短，否则gif的资源会很大，影响页面的加载速度
</code></pre>
<p>来看一个OPPO开发者大会的例子：<a target="_blank" rel="noopener" href="https://open.oppomobile.com/odc20/mobile/">https://open.oppomobile.com/odc20/mobile/</a></p>
<img src="/images/h5-bg-animation/1.gif" width="300" alt="1" align="center">

<p>后面的背景动效具体代码如下：</p>
<img src="/images/h5-bg-animation/2.png" width="800" alt="1" align="center">

<p>img中的src指向了一个gif。</p>
<p>这个gif体积大小为1.8M，时长为1s。</p>
<p>可以看到，虽然只有1s的gif，但体积大小已经到了1.8M，针对于H5页面来说已经挺大了。</p>
<p>所以，若不是简短的循环动画，不推荐使用gif方案。并且，在设计动效时，需要与美术同学沟通好，不能让其随意发挥，不然可能最后拿到的gif资源过大，导致该方案行不通。</p>
<p><strong>关键点：循环，简短，体积小，时间短。</strong></p>
<p><strong>优点：实现简单，动画效果细腻</strong></p>
<p><strong>缺点：限制较多，资源较大，影响页面性能</strong></p>
<h2 id="二、帧动画"><a href="#二、帧动画" class="headerlink" title="二、帧动画"></a>二、帧动画</h2><p>帧动画的设计有如下两种，基本原理是一致的：</p>
<ol>
<li>通过一张张图片切换实现动画效果。在vue框架中，就可以先加载好图片，然后利用v-show进行图片切换</li>
<li>将逐帧图片放到一张长图中，利用css控制图片展示的位置，来实现动画的效果，这种方案需要设计配合输出一张帧动画长图</li>
</ol>
<h4 id="1、切换图片实现"><a href="#1、切换图片实现" class="headerlink" title="1、切换图片实现"></a>1、切换图片实现</h4><img src="/images/h5-bg-animation/3.gif" width="300" alt="3" align="center">

<p>以上是商店某次活动的效果gif图，图中闪电效果以及手机转动效果均是利用切换图片来实现的帧动画。文末会附上这次活动项目的代码：vbase.zip。</p>
<p>拿闪电效果举例：</p>
<ul>
<li>素材有以下4张图片</li>
</ul>
<img src="/images/h5-bg-animation/4.png" width="100" alt="4" align="center">
<img src="/images/h5-bg-animation/5.png" width="100" alt="4" align="center">
<img src="/images/h5-bg-animation/6.png" width="100" alt="4" align="center">
<img src="/images/h5-bg-animation/7.png" width="100" alt="4" align="center">


<ul>
<li>在页面启动时，可以在页面中创建6个img标签，并将各个图片的地址赋值给各个img的src属性，并且这几个img的display都为none，不展示（也可以展示第一张作为过渡，等所有图片加载出来后再开始执行动画）</li>
<li>通过setInterval函数，控制好图片展示的时间以及切换，便可实现动画效果。</li>
</ul>
<h4 id="2、长图滑动图片实现"><a href="#2、长图滑动图片实现" class="headerlink" title="2、长图滑动图片实现"></a>2、长图滑动图片实现</h4><img src="/images/h5-bg-animation/10.png" width="300" alt="4" align="center">



<p>上图的动画效果是利用一张等间距的动画分解逐帧图片（类似雪碧图），由js脚本模拟编写或是使用css3新属性step()制作而成的。</p>
<p>step()在移动端的兼容性是很好的，但使用比较小众。逐帧动画和GIF动画的差别在于，脚本可以控制逐帧动画的快慢和动作的暂停，而GIF动画无法在后期通过代码进行动画速率及透明度的修改。</p>
<p>以下是CSS代码的实现：</p>
<img src="/images/h5-bg-animation/11.png" width="500" alt="4" align="center">

<p>通过animation属性控制背景图片展示的位置来实现帧动画效果。</p>
<p>以上两种方案都需要手头有帧动画的逐帧图片，若手上只有设计师给的动画效果视频怎么办？</p>
<p>这里有一个不错的网站推荐给大家：<a target="_blank" rel="noopener" href="https://www.img2go.com/convert-to-jpg%EF%BC%88%E5%82%BB%E7%93%9C%E5%BC%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%B8%A7%E5%8A%A8%E7%94%BB%E5%9B%BE%E7%89%87%E5%B7%A5%E5%85%B7%EF%BC%89">https://www.img2go.com/convert-to-jpg（傻瓜式视频转帧动画图片工具）</a></p>
<p><strong>优点：兼容性好，实现难度不高</strong></p>
<p><strong>缺点：资源较大影响性能，动画可能不够细腻</strong></p>
<h2 id="三、SVG"><a href="#三、SVG" class="headerlink" title="三、SVG"></a>三、SVG</h2><img src="/images/h5-bg-animation/12.gif" width="300" alt="4" align="center">

<p>上图是SVG实现的一个简单的背景动效，具体的实现难度与动画的复杂程度有关，有兴趣的同学可以进一步研究SVG动画：<a target="_blank" rel="noopener" href="https://aotu.io/notes/2017/01/22/snapsvg/index.html">https://aotu.io/notes/2017/01/22/snapsvg/index.html</a></p>
<p>SVG动画效果以线条、形状变化为主，需要根据具体的场景来决策是否要使用svg进行实现。</p>
<p><strong>优点：兼容性好，性能佳</strong></p>
<p><strong>缺点：实现复杂</strong></p>
<h2 id="四、video"><a href="#四、video" class="headerlink" title="四、video"></a>四、video</h2><p>使用video标签来设置背景的好处就在于：可以直接引入视频，且无需过多的代码设计，简单粗暴。但由于H5端各个浏览器以及平台对video标签的处理不尽相同，且无法自动播放，还有可能被浏览器拦截，所以video标签作为背景在PC端上使用得更多，H5端要使用的话必须要平台支持video标签自动播放。</p>
<p>比如在各个手机端的浏览器中基本上是无法自动播放的，而在应用商店或者某些平台的webView中，是可以设置video自动播放，此时就能使用video标签作为背景，引入一个视频，使用方法也很简单：设置一个video标签，配置一些相应的属性即可。video标签的mdn文档：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video</a></p>
<p><strong>优点：实现简单</strong></p>
<p><strong>缺点：H5上对自动播放的兼容性差，无法自动播放时便无法使用此方法进行实现</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述简单总结阐述了四种背景动效的实现方案，分别是gif、逐帧动画、SVG、video，每种方案都有其相应的优缺点，具体的使用需要根据具体场景去分析。在制作背景动效的过程中作为开发人员有以下几点需要注意：</p>
<ul>
<li>有问题及时与设计师沟通，效果无法实现的时候尝试与设计师探讨B方案，比如换用一种效果，或者以可以实现的效果平缓过渡，保证用户体验的同时不会严重影响视觉效果</li>
<li>在设计师出完设计动效之后，必须进行评审，明确通知产品以及设计师哪些效果可以做，哪些效果做起来成本会很高，从项目初期就确定好整体的效果以及实现方案。这样做是为了后续保证项目质量以及不会因为动效实现难而导致延期或者不做</li>
<li>具体的动效也需要根据具体的场景进行分析，这就要求开发人员需要有足够的动效设计开发经验，对所需要做的动效心里有个尺度</li>
</ul>
</p>
      <div class="post-button"><a class="btn" href="/2021/05/07/h5-bg-animation/" rel="noopener"><i class="fa fa-angle-double-right fa-fw"></i>Read More</a></div>
    </div>
  </div>




<footer>
  <div>
  Copyright &copy; 2021.<a href="/">ROBIN-3910</a><br>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme <a href="https://lx.js.org" target="_blank">Lx</a><br>
  </div>
</footer>

  </div>
</div>
</div>

<button class="hamburger hamburger--arrow-r" type="button">
    <div class="hamburger-box">
      <div class="hamburger-inner"></div>
    </div>
</button> 
<div class="menu visibility">
  <div class="menu-head">
    <span class="layer">
      <div class="col">
        <div class="row for-pic">
          <div class="profile-pic">
            <a href="/"><img src="/images/avatar.jpeg" alt="rob-曾洛镔"/></a>
          </div>
        </div>
        <div class="row for-name">
          <p>rob-曾洛镔</p>
          <span class="tagline">Hello, World!</span>
        </div>
      </div>
    </span>
  </div>
  <nav class="menu-container">
  <ul class="menu-items">
    <li><a href="/"><i class="fa fa-home fa-fw"></i>Home</a></li>
    <li><a href="/archives/"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
    
    <li class="has-sub"><span class="dropdown-heading">
      <i class="fa fa-bookmark fa-fw"></i>Pages</span>
        <ul>
          <li><a href="/guestbook/">Guestbook</a></li>
        <li><a href="/about/">About</a></li>
        </ul>
    </li>
    <li class="has-sub"><span class="dropdown-heading">
      <i class="fa fa-link fa-fw"></i>Friends</span>
        <ul>
          <li> <a href="https://lx.js.org" target="_blank">Theme-Lx</a></li>
        </ul>
    </li>
  </ul>
  </nav>
</div>

<div class="gototop js-top">
  <a href="#" class="js-gotop"><i class="fa fa-arrow-up"></i></a>
</div>
<script src="//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/js/jquery.easing.min.js"></script>
<script>
(function () {
	"use strict";
	var goToTop = function() {
		$(".js-gotop").on("click", function(event){
			event.preventDefault();
			$("html, body").animate({
				scrollTop: $("html").offset().top
			}, 500, "easeInOutExpo");
			return false;
		});
		$(window).scroll(function(){
			var $win = $(window);
			if ($win.scrollTop() > 200) {
				$(".js-top").addClass("active");
			} else {
				$(".js-top").removeClass("active");
			}
		});
	};
	$(function(){
		goToTop();
	});
}());
</script>


</body>
</html>
