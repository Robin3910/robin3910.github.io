<!DOCTYPE html>
<html lang="ch">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme-color" content=#58b77a>
  <title>ROBIN-3910</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="rob-曾洛镔">
  <meta name="keywords" content="">
  <meta name="description" content="rob的个人博客网站，记录编码/学习/生活日常">
  <script id="hexo-configurations">
  var CONFIG = {
    root: '/',
    theme: 'lx',
    version: '0.3.9',
    localsearch: {
      "enable": 'false',
      "trigger": "auto",
      "top_n_per_article": "1",
      "unescape": 'false',
      "preload": 'false'
    },
    path: '-'
  };
</script>

  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/css/main.min.css">
  <style type="text/css">
    pre,
    code {
      font-family: 'Fira Code', monospace;
    }
    html {
      font-family: sans-serif;
    }
    body {
      font-family: sans-serif;
    }
    h1, h2, h3, h4, h5, figure {
      font-family: sans-serif;
    }
    .menu-container{
      font-family: sans-serif;
    }
  </style>

  <script src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/js/jquery.jside.menu.js"></script>
	<script>
	$(document).ready(function(){
	$(".menu-container").jSideMenu({
	    jSidePosition: "position-right",
	    jSideSticky: true,
	    jSideSkin: "greenish",
	     });
	}); 
	</script>
  
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Fira Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
<meta name="generator" content="Hexo 5.4.0"></head>
<body>
<div id="page">

<div id="lx-aside" style="background-image: url(//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/images/cover.jpeg)">
  <div class="overlay">
  <div class="featured">
    <div class="avatar"><a href="/"><img style="width: 100px;height: 100px;" src="/images/avatar.jpeg"></a></div>
    <span>rob-曾洛镔</span>
    <h1>ROBIN-3910</h1>
    <span>——今天大刀🗡没带过来，就不砍你需求了</span>
    <div class="social-links">
    <a href="https://github.com/Robin3910" target="_blank"><i class="fa fa-github fa-fw"></i></a>
    <a href="robin3910@163.com" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
</div>
  </div>
  </div>
</div>

<div id="lx-main-content">
  <div class="lx-post"> 

  <div class="lx-entry padding">
    <div>
      <h2 class="title"><a href="/2021/05/07/viewport/">移动端适配总结</a></h2>
      <span class="lx-post-detail"><i class="fa fa-calendar-o"></i> 2021-05-07</span>
      <p><p>如果下面这行代码经常见到，但又对其一知半解，那么这篇文章也许可以帮你解惑</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="一、基础知识梳理"><a href="#一、基础知识梳理" class="headerlink" title="一、基础知识梳理"></a>一、基础知识梳理</h2><h3 id="1-1、像素"><a href="#1-1、像素" class="headerlink" title="1.1、像素"></a>1.1、像素</h3><h4 id="a-物理像素"><a href="#a-物理像素" class="headerlink" title="a.物理像素"></a>a.物理像素</h4><p>物理像素也就是移动设备中所提到的分辨率，比如手机的分辨率为<code>750x1334</code>像素，其指的是屏幕的垂直方向上有<code>1334</code>个物理像素块，水平方向上有<code>750</code>个像素块。其分辨率越高，所展示的图像就越清晰。</p>
<h4 id="b-设备独立像素-device-independent-pixels-CSS像素"><a href="#b-设备独立像素-device-independent-pixels-CSS像素" class="headerlink" title="b.设备独立像素(device-independent pixels)/CSS像素"></a>b.设备独立像素<code>(device-independent pixels)</code>/CSS像素</h4><p>设备的独立像素，不同于物理像素，更多指的是设计稿中的尺寸，比如设计稿中一个Img的宽高为<code>100x100</code>像素，这个就是独立像素，也对应于css像素，是虚拟化的。</p>
<p>那么，可能会有疑问，这手机分辨率有<code>750x1334</code>像素，但是屏幕大小只有<code>375x667</code>像素，这两者有什么关系呢？</p>
<p>这里就需要引入css像素，也就是设备独立像素。css像素中1px可以代表多个物理像素，在dpr为2的手机中，CSS <code>1px</code>可以对应2个物理像素，也就是相比于分辨率为<code>375x667</code>的手机来说，<code>750x1334</code>分辨率的手机会更加清晰细腻。</p>
<p>如下图所示：这是<code>dpr = 2</code>的情况，最外框为css的<code>1px</code>，但其却覆盖了4个物理像素（蓝色的小方块）</p>
<img src="/images/viewport/1.png" width = "100" alt="1" align=center />

<p>当用户缩小时：物理像素（蓝色小方块）是不会改变的，此时一个物理像素从原来只覆盖1/4的CSS像素变成了可覆盖大于7/10的CSS像素，相当于一个物理像素所能展示的CSS像素更多，所以用户所能看到的内容也更多，但图像变小</p>
<img src="/images/viewport/2.png" width = "100" alt="1" align=center />

<p>反之，当用户放大时：原来一个CSS像素仅需要4个物理像素便能展示，放大后一个CSS像素所需的物理像素可能要8-9个（大概），所以能展示的CSS像素变少，图像变大，用户所能看到的内容也就变少了</p>
<img src="/images/viewport/3.png" width = "100" alt="1" align=center />

<h3 id="1-2、设备像素比dpr"><a href="#1-2、设备像素比dpr" class="headerlink" title="1.2、设备像素比dpr"></a>1.2、设备像素比dpr</h3><p><code>dpr=物理像素/独立像素</code>，通过js可以获取：<code>window.devicesPixelRatio</code>。</p>
<h2 id="二、视口viewport"><a href="#二、视口viewport" class="headerlink" title="二、视口viewport"></a>二、视口viewport</h2><h3 id="2-1、PC与移动端的视口viewport"><a href="#2-1、PC与移动端的视口viewport" class="headerlink" title="2.1、PC与移动端的视口viewport"></a>2.1、PC与移动端的视口viewport</h3><h4 id="2-1-1、PC端视口"><a href="#2-1-1、PC端视口" class="headerlink" title="2.1.1、PC端视口"></a>2.1.1、PC端视口</h4><p>在<code>html</code>、<code>body</code>设置<code>width:100%;height:100%;</code>的时候，它并不是无效的。100%这种百分数应该是继承父元素而来的。那在这里是继承哪里的呢？</p>
<p>在PC浏览器中，有一个用来约束CSS布局视口的东西，又叫做初始包含块。这也就是所有宽高继承的由来。除去<code>margin</code>、<code>padding</code>，浏览器布局视口<code>layout viewport</code>和可视窗口<code>visual viewport</code>宽高是一致的，统称为视口<code>viewport</code>，同时也和浏览器本身的宽度一致。</p>
<p>举个例子：下图中，当前浏览器的宽度<code>1365px</code>，则相应的body宽度也为<code>1365px</code>，文字显示正常，阅读无障碍</p>
<p>通过<code>document.documentElement.clientWidth</code>可以获取布局视口。</p>
<img src="/images/viewport/4.png" width = "800" alt="1" align=center />



<h4 id="2-2、移动端"><a href="#2-2、移动端" class="headerlink" title="2.2、移动端"></a>2.2、移动端</h4><h5 id="2-2-1、布局视口"><a href="#2-2-1、布局视口" class="headerlink" title="2.2.1、布局视口"></a>2.2.1、布局视口</h5><img src="/images/viewport/5.png" width = "400" alt="1" align=center />


<p>在移动端，默认的情况下，移动端浏览器厂商为了让用户在小屏幕下传统的PC网页也能够很好地展示，一般会把布局视口宽度设置地很大去存放页面，在<code>768px ~ 1024px</code>之间，最常见的宽度是<code>980px</code>。这个宽度可以通过<code>document.documentElement.clientWidth</code>得到。</p>
<h5 id="2-2-2、视觉视口"><a href="#2-2-2、视觉视口" class="headerlink" title="2.2.2、视觉视口"></a>2.2.2、视觉视口</h5><img src="/images/viewport/6.png" width = "400" alt="1" align=center />


<p>对于视觉视口来说，这个东西是呈现给用户的，它是用户看到网页区域内CSS像素的数量。（CSS像素的数量越多，说明展示的页面元素越多，看到的页面元素也就越小）</p>
<p>值得注意的是，在移动端缩放不会改变布局视口的宽度，当缩小的时候，屏幕覆盖的css像素变多，视觉视口变大，看到的字体图形字体变小，反之亦然。</p>
<p>而在PC端，缩放对应布局宽度和视觉窗口宽度都是联动的。而浏览器宽度本身是固定的，无论怎么缩放都不受影响。</p>
<h5 id="2-2-3、视口缺陷"><a href="#2-2-3、视口缺陷" class="headerlink" title="2.2.3、视口缺陷"></a>2.2.3、视口缺陷</h5><img src="/images/viewport/7.png" width = "400" alt="1" align=center />

<p>从上图可以看到，用户手机屏幕所展示的内容（<code>visual viewport</code>）仅占了<code>layout viewport</code>的一部分，并不能全部展示出来。</p>
<p>通过<code>chrome</code>模拟出手机的屏幕</p>
<p>如上图所示，布局视口的宽度（这里<code>body</code>被默认设置成了<code>980px</code>）是要远远大于移动端浏览器的宽度(<code>360px</code>)的。大多数浏览器会默认铺开整个布局视口到整个屏幕中，导致页面中的字体非常小，阅读体验非常差。</p>
<p>试想一下，如果一个网页不对移动端进行适配，用户进行阅读的时候，由于字体太小，就不得不手动放大以便于阅读，但是放大的时候另外一个问题又出现了：</p>
<img src="/images/viewport/8.png" width = "400" alt="1" align=center />

<p>从上图中可以看到，虽然文字变大了，但是相应的，屏幕中所显示的信息也变少了，用户需要手动去滑动整个页面让目标信息展示出来。</p>
<h5 id="2-2-4、理想视口"><a href="#2-2-4、理想视口" class="headerlink" title="2.2.4、理想视口"></a>2.2.4、理想视口</h5><p>所以后来苹果引入了理想视口的概念，它对设备来说是最理想的布局视口尺寸，用户进入页面时就不需要手动再去缩放页面。</p>
<p>所以便有了这段代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong><code>width=device-width</code>：</strong> 把布局视口设置成为浏览器（屏幕）的宽度。</p>
<p><strong><code>initial-scale=1</code> ：</strong>初始缩放的比例是1，使用它的时候，同时也会将布局视口的尺寸设置为初始缩放比例后的尺寸。而缩放的尺寸就是基于屏幕的宽度来的，也就起到了和<code>width=device-width</code>同样的效果。</p>
<p>每个移动设备浏览器中都有一个理想的宽度，这个理想的宽度是指css中的宽度，跟设备的物理宽度没有关系，在css中，这个宽度就相当于100%的所代表的那个宽度（这个其实就是<code>devices-width</code>）。</p>
<p>我们可以用<code>meta</code>标签把<code>viewport</code>的宽度设为那个理想的宽度，如果不知道这个设备的理想宽度是多少，那么用<code>device-width</code>这个特殊值就行了，同时<code>initial-scale=1</code>也有把<code>viewport</code>的宽度设为理想宽度的作用。</p>
<p>为什么需要有理想的<code>viewport</code>呢？比如一个分辨率为<code>320x480</code>的手机理想<code>layout viewport</code>的宽度是<code>320px</code>，而另一个屏幕尺寸相同但分辨率为<code>640x960</code>的手机的理想<code>layout viewport</code>宽度也是为<code>320px</code>，那为什么分辨率大的这个手机的理想宽度要跟分辨率小的那个手机的理想宽度一样呢？</p>
<p>这是因为，只有这样才能保证同样的网站在不同分辨率的设备上看起来都是一样或差不多的。实际上，现在市面上虽然有那么多不同种类不同品牌不同分辨率的手机，但它们的理想<code>viewport</code>宽度归纳起来无非也就 <code>320、360、384、400</code>等几种，都是非常接近的，理想宽度的相近也就意味着我们针对某个设备的理想<code>viewport</code>而做出的网站，在其他设备上的表现也不会相差非常多甚至是表现一样的。</p>
<h2 id="三、移动端适配方案"><a href="#三、移动端适配方案" class="headerlink" title="三、移动端适配方案"></a>三、移动端适配方案</h2><p>在移动端上，有了<code>layout viewport</code>的固定宽度之后，再进行移动端适配就不再是难事，简单总结了如下几种移动端适配的方法：</p>
<h3 id="3-1、flex弹性盒模型实现的移动端适配"><a href="#3-1、flex弹性盒模型实现的移动端适配" class="headerlink" title="3.1、flex弹性盒模型实现的移动端适配"></a>3.1、flex弹性盒模型实现的移动端适配</h3><p>以淘宝移动端页面为例：<a target="_blank" rel="noopener" href="https://main.m.taobao.com/index.html">https://main.m.taobao.com/index.html</a></p>
<p>通过将盒子设置成<code>flex</code>布局以及<code>width:100%</code>，根据需要来设置<code>justify-content</code>以及<code>align-items</code>来对齐居中等，实现在不同屏幕尺寸的移动端下的适配。</p>
<p>在需要适配的地方使用弹性盒模型以及百分比，在不需要适配的地方使用px，举个例子，底部tap就是适配的，而中间的导航，如”天猫新品，今日爆款“的图标块是原始<code>px</code>尺寸。</p>
<img src="/images/viewport/9.png" width = "400" alt="1" align=center />



<p>这种适配方案在手机端是OK的，但一旦转换到ipad端….，如下图所示，中间的导航栏由于<code>div</code>宽度过长，而其中的图标大小还是原始尺寸，导致盒子过大，图标无法填充满整个盒子，更别说是切换分页了（这个盒子中是有分页器的）</p>
<img src="/images/viewport/10.png" width = "400" alt="1" align=center />

<p><strong>这种适配方案的优缺点：</strong></p>
<p><strong>优点：</strong><br>实现简单便捷，<code>flex+百分比/flex+vw</code>灵活方便，无需引入其他库便可以实现大部分手机的屏幕适配<br><strong>缺点：</strong><br>针对于平板类的移动端，还需要另外做适配才能兼容，比较繁琐</p>
<h3 id="3-2、rem-px2rem适配方案"><a href="#3-2、rem-px2rem适配方案" class="headerlink" title="3.2、rem+px2rem适配方案"></a>3.2、rem+px2rem适配方案</h3><blockquote>
<p>在W3C官网上是这样描述rem的——“font size of the root element” 。</p>
</blockquote>
<p>基本思路：</p>
<p>假如说我们的设计稿为<code>750px</code>，现在把设计稿分成<code>10</code>份，一份就为<code>75px</code>。</p>
<p>同样，获取到移动端屏幕的宽度，将其分成十份，并且将每份的大小设置成<code>1rem</code>，也就是设置<code>html</code>的<code>font-size</code>。设置<code>div</code>大小时，便可用<code>rem</code>进行设置，比如，设计稿中一个<code>Img</code>是<code>75 x 75</code>，代码中就可以设置这个<code>img</code>为<code>1rem</code>，即<code>img</code>的宽度是设计稿的<code>1/10</code>，对应的比例在手机中也就是屏幕宽度的<code>1/10</code>，也就是<code>1rem</code>。分成几份全由自己来决定，可以分成<code>10</code>份，也可以分成<code>20</code>份，等等。</p>
<p>这样可以实现适配，但是问题在于，每次写css的宽高时，都需要通过自己再进行计算转换成<code>rem</code>，比如如果有个<code>img</code>是<code>50x50</code>像素，它在设计稿中的比例是 <code>50/75 = 0.667</code>份，相当于在代码中我们需要写<code>0.667rem</code>，这其实是非常繁琐且低效的。</p>
<p>但是，现有工具可以帮我们解决这个问题：<code>postcss-px2rem</code>。我们在写代码的时候还是可以用<code>px</code>，设计稿中写了多少<code>px</code>我们代码中就写多少<code>px</code>，在代码编译阶段，<code>postcss-px2rem</code>就会将<code>px</code>编译成相应的<code>rem</code>，这样我们就无需手动去换算，这是一种比较成熟的移动端适配方案。（这里不深入探究<code>1px</code>的问题，解决<code>1px</code>问题需要配合<code>scale</code>以及<code>dpr</code>进行）</p>
<p>下面以<code>vue</code>项目且<code>750px</code>设计稿为例：</p>
<p>我们设定设计稿<code>html</code>的<code>fontSize = 75px</code>，则<code>1rem = 75px</code>(分成10份)，体现在<code>postCss-px2rem</code>中就是<code>remUnit: 75</code>。这时在代码中写<code>1px</code>，代码编译后会转换成<code> 1/75 = 0.01333rem</code>，而这个<code>0.01333rem</code>是相对于移动端屏幕的，</p>
<p>举个例子：如果移动端屏幕为<code>375px</code>，且我们对移动端网页的<code>html</code>设置了<code>fontSize = 375 / 10 = 37.5px</code>，则<code>0.013333rem = 37.5 * 0.013333 = 0.5px</code>，其比例和设计稿是一致的，所以显示在屏幕中也就是正常的。</p>
<p>设置<code>font-size</code>的代码如下（引入的方式按需而定，比如这段代码可以通过一个<code>script</code>标签内联在<code>app.html</code>）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> width = <span class="built_in">document</span>.documentElement.clientWidth;</span><br><span class="line"><span class="keyword">const</span> html = <span class="built_in">document</span>.getElementByTagName(<span class="string">&#x27;html&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">html.style.fontSize = width / <span class="number">10</span> + <span class="string">&#x27;px&#x27;</span>;</span><br></pre></td></tr></table></figure>


<p>配置<code>postCss-px2rem</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// postcss.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">plugins</span>: &#123;</span><br><span class="line">        <span class="attr">autoprefixer</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&#x27;postcss-px2rem&#x27;</span>: &#123;</span><br><span class="line">            <span class="attr">remUnit</span>: <span class="number">75</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="3-3、vw-px2rem适配方案"><a href="#3-3、vw-px2rem适配方案" class="headerlink" title="3.3、vw+px2rem适配方案"></a>3.3、<code>vw+px2rem</code>适配方案</h3><p>在移动端适配发展的初期，浏览器对<code>vw</code>的兼容性相比于<code>rem</code>是差很多的，但是随着浏览器的发展，慢慢地对<code>vw</code>的兼容相比于以前有了天翻地覆的变化</p>
<p>回想<code>rem</code>适配，若是将设计稿分成100份的时候，其实<code>1rem</code>也就对应了<code>1vw</code>，两者的原理是差不多的，<code>vw</code>的好处就体现在其不再需要引入<code>js</code>，直接通过css代码便可以设置，</p>
<p>代码如下：</p>
<img src="/images/viewport/11.png" width = "600" alt="1" align=center />

<p>其中，还是将设计稿分成了十份，如果设计稿为<code>1080px</code>，则一份为<code>108</code>像素，注意，这两个值是通过自己去设置的，并不是一定要这样设置，可以根据设计稿以及自己方便计算来设置；</p>
<p>设计稿的<code>html fontSize</code>设计成<code>1/10</code>的设计稿宽度<code>108</code>，所以<code>postCss-px2rem</code>中的<code>remUnit</code>就为<code>108</code>，相应的移动端页面中<code>1rem = 10vw</code>，相当于在<code>375</code>的屏幕中<code>1rem = 37.5px</code>。</p>
<p>同时，也可以利用<code>px2rem</code>工具，写代码时就可以直接利用<code>px</code>。</p>
<p><strong><u>参考文章：</u></strong></p>
<p><strong>viewport</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.quirksmode.org/mobile/viewports.html">A tale of two viewports — part one</a></p>
<p><a target="_blank" rel="noopener" href="https://www.quirksmode.org/mobile/viewports2.html">A tale of two viewports — part t</a></p>
<p><a target="_blank" rel="noopener" href="https://www.quirksmode.org/mobile/metaviewport/">Meta viewport</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/2050/p/3877280.html">移动前端开发之viewport的深入理解</a></p>
<p><strong>移动端适配</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/amfe/article/issues/17">使用Flexible实现手淘H5页面的终端适配</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/entry/5a9d07ee6fb9a028c149f55b">再聊移动端页面的适配</a></p>
</p>
      <div class="post-button"><a class="btn" href="/2021/05/07/viewport/" rel="noopener"><i class="fa fa-angle-double-right fa-fw"></i>Read More</a></div>
    </div>
  </div>
  <div class="lx-entry padding">
    <div>
      <h2 class="title"><a href="/2021/05/07/okr-record/">OKR阅读心得</a></h2>
      <span class="lx-post-detail"><i class="fa fa-calendar-o"></i> 2021-05-07</span>
      <p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>OKR</code>全称是<code>Objective and key results</code>，目标与<code>**关键结果法**</code>。</p>
<p>它关注<code>目标</code>，是一套定义和跟踪目标及其完成情况的管理工具和方法。<u>目标是指你想完成什么事情</u>；<u>关键结果是确认你是否做到了这件事情</u>，即关键结果是对于目标实现的量化。</p>
<p>作者杜尔自己多年来使用<code>OKR</code>，还在不同规模和性质的企业和组织中推广<code>OKR</code>。他在本书里介绍了如何使用<code>OKR</code>，实现增长。他还邀请包括比尔·盖茨等在内的<code>OKR</code>的实践者。</p>
<p>以第一人称的方式，讲述自己使用<code>OKR</code>的故事，通过生动的案例，展示<code>OKR</code>的力量。</p>
<h3 id="OKR与KPI"><a href="#OKR与KPI" class="headerlink" title="OKR与KPI"></a><code>OKR</code>与<code>KPI</code></h3><p>其实一说到绩效考核，大家可能马上就会想起<code>KPI</code>，也就是关键绩效指标。这两个工具的区别在哪儿呢？最直接的区别是，<code>KPI</code>有明确的考核指标，跟奖金激励挂钩，但是<code>OKR</code>更侧重目标管理，</p>
<p>跟升职加薪没有直接关系。<code>KPI</code>是一种压力管理方法，能让你为了完成考核指标而埋头工作，但你有可能只顾得上完成指标，而不管实际效果。<code>OKR</code>则是一种愿景管理方法，让你工作时不会偏离方向，取得实实在在的进步。</p>
<h3 id="OKR特点"><a href="#OKR特点" class="headerlink" title="OKR特点"></a><code>OKR</code>特点</h3><p>关于<code>OKR</code>的一些特点：</p>
<h4 id="在设定OKR上："><a href="#在设定OKR上：" class="headerlink" title="在设定OKR上："></a>在设定<code>OKR</code>上：</h4><ul>
<li>要使目标具有使命感，意义感；</li>
<li>重要且具体，以结果导向</li>
<li>关键结果明确，有时间节点</li>
<li>具有挑战性</li>
</ul>
<h4 id="OKR的四大利器："><a href="#OKR的四大利器：" class="headerlink" title="OKR的四大利器："></a><code>OKR</code>的四大利器：</h4><ul>
<li>让整个组织聚焦在重要的事情上</li>
<li>对责任进行追踪</li>
<li>促进团队的协同</li>
<li>挑战不可能</li>
</ul>
<h4 id="OKR的使用："><a href="#OKR的使用：" class="headerlink" title="OKR的使用："></a><code>OKR</code>的使用：</h4><p>​    <u>围绕CFR展开（comversation, feedback, recognition）沟通、反馈、评价</u></p>
<p><strong>C：沟通</strong> - 不断围绕一个时间段内的<code>OKR</code>进行沟通，最终达成共识</p>
<p><strong>F：反馈</strong> - 根据<code>OKR</code>的进行进度不断反馈，追踪<code>OKR</code>的进展</p>
<p><strong>R：评价</strong> - 对<code>OKR</code>的关键结果完成情况评价，打分并总结。</p>
<h3 id="阅读《OKR》心得体会："><a href="#阅读《OKR》心得体会：" class="headerlink" title="阅读《OKR》心得体会："></a>阅读《OKR》心得体会：</h3><p>制定目标的过程应该极为小心，不可让目标太容易实现，也不可让目标过于宏达导致在规定的时间内无法实现而产生懈怠，所以目标的制定是<code>OKR</code>的难点之一。<br>所制定的目标必须具有挑战性，而不是日常反复的工作，是需要走出舒适区才能实现的目标。</p>
<p>要小心区别重要事件和紧急事件，很多容易先做紧急事件，而不紧急的重要事件一直被排在后面而导致最终没办法完成既定的目标。其实工作中很多这样的场景，<br>业务需求频繁导致需要把精力大部分放置于业务需求当中，于我目前而言，是好事，刚接手这一工作，最重要的就是熟悉业务，而熟悉业务最简单的方式就是<br>多做需求。但是实现业务需求对个人的提升是有瓶颈的，可能一两年后，如果没有补充自己的知识面，深究技术原理，仅停留在实现功能层面上的话，便很难再有提升。<br>所以，要合理分配精力，对业务需求保质保量，同时通过对重要事件的完成，提升自己，反向推动提升工作效率，两者相辅相成。</p>
<p>书中还有关于<code>OKR</code>的一点我觉得十分有价值，就是<code>OKR</code>是相当透明的，公司上下之间目标明确，每个人都可以看到任何人的<code>OKR</code>，一线人员可以不断调整自己的<code>OKR</code>与<br>公司<code>OKR</code>对齐，通过自己<code>OKR</code>的实现，来推动公司的<code>OKR</code>；而同事与同事之间也能相互了解对方正在做什么事情，相互配合，互相促进。这其实是共赢的，公司有提升，职员也有提升。</p>
</p>
      <div class="post-button"><a class="btn" href="/2021/05/07/okr-record/" rel="noopener"><i class="fa fa-angle-double-right fa-fw"></i>Read More</a></div>
    </div>
  </div>
  <div class="lx-entry padding">
    <div>
      <h2 class="title"><a href="/2021/05/07/ts-notes/">ts随笔</a></h2>
      <span class="lx-post-detail"><i class="fa fa-calendar-o"></i> 2021-05-07</span>
      <p><pre><code>该笔记主要记录了一些编码过程中比较常见但是又容易模糊的知识点
</code></pre>
<p><strong>原始类型</strong>：<code>string</code>, <code>boolean</code>, <code>number</code>, <code>null</code>, <code>void</code>, <code>symbol</code>, <code>undefined</code>, <code>bigint</code></p>
<p>Tip: 编码过程中也有类似的关键字<code>Boolean</code>, <code>Number</code>, <code>String</code>等，这是JS的构造函数，和类型完全不同。</p>
<p><strong>Bigint</strong></p>
<p>使用Bigint可以安全地存储和操作大整数，即这个数已经超过了JS构造函数<code>Number</code>能够表示的安全整数范围，使用<code>Bigint</code>需要使用<code>ESnext</code>编译辅助库。</p>
<p>下面两段代码就可以看出区别：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> max = <span class="built_in">Number</span>.MAX_SAFE_INTEGER; <span class="comment">// 2^53-1</span></span><br><span class="line"><span class="keyword">const</span> max1 = max + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> max2 = max + <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(max1 === max2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> max = <span class="built_in">BigInt</span>(<span class="built_in">Number</span>.MAX_SAFE_INTEGER); <span class="comment">// 2^53-1</span></span><br><span class="line"><span class="keyword">const</span> max1 = max + <span class="number">1n</span>;</span><br><span class="line"><span class="keyword">const</span> max2 = max + <span class="number">2n</span>;</span><br><span class="line"><span class="built_in">console</span>.log(max1 === max2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>





<p><strong>unknown和any</strong></p>
<p><code>unknown</code>是更安全的<code>any</code>类型，<code>any</code>类型在赋值之前，可以通过.去获取属性和方法不会抛错，但是<code>unknown</code>会。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value: <span class="built_in">any</span>;</span><br><span class="line">value.foo.bar; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> zoo: unknown;</span><br><span class="line">zoo.foo; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>









<p><strong>元组</strong></p>
<p>元组与数组非常相似，元组可以说是类型更加严格的数组。</p>
<p>元组定义完后可以通过<code>push</code>添加元素，但是获取时会报错</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">x = [<span class="string">&quot;robin&quot;</span>, <span class="number">10</span>]; <span class="comment">// ok</span></span><br><span class="line">x = [<span class="number">10</span>]; <span class="comment">// error</span></span><br><span class="line"></span><br><span class="line">x.push(<span class="number">2</span>);</span><br><span class="line">x[<span class="number">2</span>]; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>







<p><strong>枚举的本质</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Direction&#123;</span><br><span class="line">		up,</span><br><span class="line">		left,</span><br><span class="line">		down,</span><br><span class="line">		right</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Direction.up) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(Direction[<span class="number">0</span>]) <span class="comment">// up</span></span><br></pre></td></tr></table></figure>

<p>从上述例子中可以看出枚举中实现了正反向同时映射，平常的例子中，一般都是正向映射，比如一个对象，<code>key =&gt; value</code>；</p>
<p>直接看看枚举编译后的JS代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Direction;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Direction</span>) </span>&#123;</span><br><span class="line">		Direction[Direction[<span class="string">&#x27;up&#x27;</span>] = <span class="number">0</span>] = <span class="string">&#x27;up&#x27;</span>;</span><br><span class="line">  	<span class="comment">// ...</span></span><br><span class="line">&#125;) (Direction || (Direction = &#123;&#125;));</span><br></pre></td></tr></table></figure>





<p><strong>实现一个完善的pick函数，用于获取对象中的value</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> KVObject &#123;</span><br><span class="line">    [key: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">o: T, names: <span class="built_in">Array</span>&lt;K&gt;</span>): <span class="title">Array</span>&lt;<span class="title">T</span>[<span class="title">K</span>]&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> names.map(<span class="function">(<span class="params">n: K</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o[n];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj: KVObject = &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&#x27;robin&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">25</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pick(obj, [<span class="string">&quot;username&quot;</span>, <span class="string">&#x27;age&#x27;</span>]));</span><br></pre></td></tr></table></figure>



<p><strong>把接口中的成员变成可选，这个场景十份常见，我们在声明一个接口后，常常在声明变量的时候去利用这个接口，但是在声明变量时，变量内的属性或者方法一时半会又给不到，这时候利用以下这个方法就可以有效兼容</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="built_in">string</span>;</span><br><span class="line">    id: <span class="built_in">number</span>;</span><br><span class="line">    token: <span class="built_in">string</span>;</span><br><span class="line">    avatar: <span class="built_in">string</span>;</span><br><span class="line">    role: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> partial&lt;T&gt; = &#123; [K <span class="keyword">in</span> keyof T]? : T[K] &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user: partial&lt;User&gt; = &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





<p><strong>类型编程：编写一个工具类型将<code>interface</code>中函数类型的名称取出来</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Part &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="built_in">number</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    subParts: Part[];</span><br><span class="line">    updatePart(newName: <span class="built_in">string</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FunctionPropName&lt;T&gt; = &#123;[K <span class="keyword">in</span> keyof T]: T[K] <span class="keyword">extends</span> <span class="built_in">Function</span> ? K: <span class="built_in">never</span>&#125;[keyof T];</span><br><span class="line"><span class="keyword">type</span> funcName = FunctionPropName&lt;Part&gt;; <span class="comment">// type funcName = &#x27;updatePart&#x27;</span></span><br></pre></td></tr></table></figure>





<p><strong>类型编程：取出下面<code>interface</code>中的可选类型（利用空对象进行扩展甄别，网上看到的一种方法，很巧妙）</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> People &#123;</span><br><span class="line">    <span class="keyword">readonly</span> n: <span class="built_in">number</span>;</span><br><span class="line">    id: <span class="built_in">string</span>;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">from</span>?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OptionalKeys&lt;T&gt; = &#123;[K <span class="keyword">in</span> keyof T]-?: (&#123;&#125; <span class="keyword">extends</span> &#123;[P <span class="keyword">in</span> K]: T[P]&#125; ? K : <span class="built_in">never</span>)&#125;[keyof T];</span><br><span class="line"><span class="keyword">type</span> r = OptionalKeys&lt;People&gt;; <span class="comment">// &#x27;age&#x27;|&#x27;from&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须属性</span></span><br><span class="line"><span class="keyword">type</span> RequiredKeys&lt;T&gt; = &#123;[K <span class="keyword">in</span> keyof T]-?: (&#123;&#125; <span class="keyword">extends</span> &#123;[P <span class="keyword">in</span> K]: T[P]&#125; ? <span class="built_in">never</span> : K)&#125;[keyof T];</span><br></pre></td></tr></table></figure>
</p>
      <div class="post-button"><a class="btn" href="/2021/05/07/ts-notes/" rel="noopener"><i class="fa fa-angle-double-right fa-fw"></i>Read More</a></div>
    </div>
  </div>
  <div class="lx-entry padding">
    <div>
      <h2 class="title"><a href="/2021/05/07/h5-bg-animation/">H5背景动效实现方案总结</a></h2>
      <span class="lx-post-detail"><i class="fa fa-calendar-o"></i> 2021-05-07</span>
      <p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通常来说，一个元素，动往往比静更能吸引用户眼球。针对于H5页面的背景，炫酷的背景动画特效能定向助力传播和品牌打造。本文将介绍几种常见的H5中背景动效的制作手法。</p>
<h2 id="一、GIF"><a href="#一、GIF" class="headerlink" title="一、GIF"></a>一、GIF</h2><p><code>gif</code>图片擅长于制作循环的小动画，使用<code>gif</code>有以下几个条件：</p>
<pre><code>1. 动画是循环的，首尾相接
2. 每次循环的时间必须要短，否则gif的资源会很大，影响页面的加载速度
</code></pre>
<p>来看一个OPPO开发者大会的例子：<a target="_blank" rel="noopener" href="https://open.oppomobile.com/odc20/mobile/">https://open.oppomobile.com/odc20/mobile/</a></p>
<img src="/images/h5-bg-animation/1.gif" width = "300" alt="1" align=center />

<p>后面的背景动效具体代码如下：</p>
<img src="/images/h5-bg-animation/2.png" width = "800" alt="1" align=center />

<p><code>img</code>中的<code>src</code>指向了一个<code>gif</code>。</p>
<p>这个<code>gif</code>体积大小为<code>1.8M</code>，时长为<code>1s</code>。</p>
<p>可以看到，虽然只有<code>1s</code>的<code>gif</code>，但体积大小已经到了<code>1.8M</code>，针对于H5页面来说已经挺大了。</p>
<p>所以，若不是简短的循环动画，不推荐使用<code>gif</code>方案。并且，在设计动效时，需要与美术同学沟通好，<br>不能让其随意发挥，不然可能最后拿到的<code>gif</code>资源过大，导致该方案行不通。</p>
<p><strong>关键点：循环，简短，体积小，时间短。</strong></p>
<p><strong>优点：实现简单，动画效果细腻</strong></p>
<p><strong>缺点：限制较多，资源较大，影响页面性能</strong></p>
<h2 id="二、帧动画"><a href="#二、帧动画" class="headerlink" title="二、帧动画"></a>二、帧动画</h2><p>帧动画的设计有如下两种，基本原理是一致的：</p>
<ol>
<li>通过一张张图片切换实现动画效果。在<code>vue</code>框架中，就可以先加载好图片，然后利用<code>v-show</code>进行图片切换</li>
<li>将逐帧图片放到一张长图中，利用<code>css</code>控制图片展示的位置，来实现动画的效果，这种方案需要设计配合输出一张帧动画长图</li>
</ol>
<h4 id="1、切换图片实现"><a href="#1、切换图片实现" class="headerlink" title="1、切换图片实现"></a>1、切换图片实现</h4><img src="/images/h5-bg-animation/3.gif" width = "300" alt="3" align=center />

<p>以上某次活动的效果<code>gif</code>图，图中闪电效果以及手机转动效果均是利用切换图片来实现的帧动画。</p>
<p>拿闪电效果举例：</p>
<ul>
<li>素材有以下4张图片</li>
</ul>
<img src="/images/h5-bg-animation/4.png" width = "100" alt="4" align=center />
<img src="/images/h5-bg-animation/5.png" width = "100" alt="4" align=center />
<img src="/images/h5-bg-animation/6.png" width = "100" alt="4" align=center />
<img src="/images/h5-bg-animation/7.png" width = "100" alt="4" align=center />


<ul>
<li>在页面启动时，可以在页面中创建6个<code>img</code>标签，并将各个图片的地址赋值给各个<code>img</code>的<code>src</code>属性，<br>并且这几个<code>img</code>的<code>display</code>都为<code>none</code>，不展示（也可以展示第一张作为过渡，等所有图片加载出来后再开始执行动画）</li>
<li>通过<code>setInterval</code>函数，控制好图片展示的时间以及切换，便可实现动画效果。</li>
</ul>
<h4 id="2、长图滑动图片实现"><a href="#2、长图滑动图片实现" class="headerlink" title="2、长图滑动图片实现"></a>2、长图滑动图片实现</h4><img src="/images/h5-bg-animation/10.png" width = "300" alt="4" align=center />



<p>上图的动画效果是利用一张等间距的动画分解逐帧图片（类似雪碧图），由<code>js</code>脚本模拟编写或是使用<code>css3</code>新属性<code>step()</code>制作而成的。</p>
<p><code>step()</code>在移动端的兼容性是很好的，但使用比较小众。逐帧动画和<code>GIF</code>动画的差别在于，<br>脚本可以控制逐帧动画的快慢和动作的暂停，而<code>GIF</code>动画无法在后期通过代码进行动画速率及透明度的修改。</p>
<p>以下是<code>CSS</code>代码的实现：</p>
<img src="/images/h5-bg-animation/11.png" width = "500" alt="4" align=center />

<p>通过<code>animation</code>属性控制背景图片展示的位置来实现帧动画效果。</p>
<p>以上两种方案都需要手头有帧动画的逐帧图片，若手上只有设计师给的动画效果视频怎么办？</p>
<p>这里有一个不错的网站推荐给大家：<a target="_blank" rel="noopener" href="https://www.img2go.com/convert-to-jpg%EF%BC%88%E5%82%BB%E7%93%9C%E5%BC%8F%E8%A7%86%E9%A2%91%E8%BD%AC%E5%B8%A7%E5%8A%A8%E7%94%BB%E5%9B%BE%E7%89%87%E5%B7%A5%E5%85%B7%EF%BC%89">https://www.img2go.com/convert-to-jpg（傻瓜式视频转帧动画图片工具）</a></p>
<p><strong>优点：兼容性好，实现难度不高</strong></p>
<p><strong>缺点：资源较大影响性能，动画可能不够细腻</strong></p>
<h2 id="三、SVG"><a href="#三、SVG" class="headerlink" title="三、SVG"></a>三、SVG</h2><img src="/images/h5-bg-animation/12.gif" width = "300" alt="4" align=center />

<p>上图是<code>SVG</code>实现的一个简单的背景动效，具体的实现难度与动画的复杂程度有关，<br>有兴趣的同学可以进一步研究<code>SVG</code>动画：<a target="_blank" rel="noopener" href="https://aotu.io/notes/2017/01/22/snapsvg/index.html">https://aotu.io/notes/2017/01/22/snapsvg/index.html</a></p>
<p><code>SVG</code>动画效果以线条、形状变化为主，需要根据具体的场景来决策是否要使用<code>svg</code>进行实现。</p>
<p><strong>优点：兼容性好，性能佳</strong></p>
<p><strong>缺点：实现复杂</strong></p>
<h2 id="四、video"><a href="#四、video" class="headerlink" title="四、video"></a>四、video</h2><p>使用<code>video</code>标签来设置背景的好处就在于：可以直接引入视频，且无需过多的代码设计，简单粗暴。<br>但由于H5端各个浏览器以及平台对video标签的处理不尽相同，且无法自动播放，还有可能被浏览器拦截，<br>所以<code>video</code>标签作为背景在PC端上使用得更多，H5端要使用的话必须要平台支持<code>video</code>标签自动播放。</p>
<p>比如在各个手机端的浏览器中基本上是无法自动播放的，而在应用商店或者某些平台的<code>webView</code>中，<br>是可以设置video自动播放，此时就能使用<code>video</code>标签作为背景，引入一个视频，使用方法也很简单：<br>设置一个<code>video</code>标签，配置一些相应的属性即可。<br>video标签的mdn文档：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video</a></p>
<p><strong>优点：实现简单</strong></p>
<p><strong>缺点：H5上对自动播放的兼容性差，无法自动播放时便无法使用此方法进行实现</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上述简单总结阐述了四种背景动效的实现方案，分别是<code>gif</code>、<code>逐帧动画</code>、<code>SVG</code>、<code>video</code>，每种方案都有其相应的优缺点，具体的使用需要根据具体场景去分析。</p>
<p>在制作背景动效的过程中作为开发人员有以下几点需要注意：</p>
<ul>
<li>有问题及时与设计师沟通，效果无法实现的时候尝试与设计师探讨B方案，比如换用一种效果，或者以可以实现的效果平缓过渡，保证用户体验的同时不会严重影响视觉效果</li>
<li>在设计师出完设计动效之后，必须进行评审，明确通知产品以及设计师哪些效果可以做，哪些效果做起来成本会很高，从项目初期就确定好整体的效果以及实现方案。这样做是为了后续保证项目质量以及不会因为动效实现难而导致延期或者不做</li>
<li>具体的动效也需要根据具体的场景进行分析，这就要求开发人员需要有足够的动效设计开发经验，对所需要做的动效心里有个尺度</li>
</ul>
</p>
      <div class="post-button"><a class="btn" href="/2021/05/07/h5-bg-animation/" rel="noopener"><i class="fa fa-angle-double-right fa-fw"></i>Read More</a></div>
    </div>
  </div>




<footer>
  <div>
  Copyright &copy; 2021.<a href="/">ROBIN-3910</a><br>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme <a href="https://lx.js.org" target="_blank">Lx</a><br>
  </div>
</footer>

  </div>
</div>
</div>

<button class="hamburger hamburger--arrow-r" type="button">
    <div class="hamburger-box">
      <div class="hamburger-inner"></div>
    </div>
</button> 
<div class="menu visibility">
  <div class="menu-head">
    <span class="layer">
      <div class="col">
        <div class="row for-pic">
          <div class="profile-pic">
            <a href="/"><img src="/images/avatar.jpeg" alt="rob-曾洛镔"/></a>
          </div>
        </div>
        <div class="row for-name">
          <p>rob-曾洛镔</p>
          <span class="tagline">Hello, World!</span>
        </div>
      </div>
    </span>
  </div>
  <nav class="menu-container">
  <ul class="menu-items">
    <li><a href="/"><i class="fa fa-home fa-fw"></i>Home</a></li>
    <li><a href="/archives/"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
    
    <li class="has-sub"><span class="dropdown-heading">
      <i class="fa fa-bookmark fa-fw"></i>Pages</span>
        <ul>
          <li><a href="/guestbook/">Guestbook</a></li>
        <li><a href="/about/">About</a></li>
        </ul>
    </li>
    <li class="has-sub"><span class="dropdown-heading">
      <i class="fa fa-link fa-fw"></i>Friends</span>
        <ul>
          <li> <a href="https://lx.js.org" target="_blank">Theme-Lx</a></li>
        </ul>
    </li>
  </ul>
  </nav>
</div>

<div class="gototop js-top">
  <a href="#" class="js-gotop"><i class="fa fa-arrow-up"></i></a>
</div>
<script src="//cdn.jsdelivr.net/npm/theme-lx@0.3.9/source/js/jquery.easing.min.js"></script>
<script>
(function () {
	"use strict";
	var goToTop = function() {
		$(".js-gotop").on("click", function(event){
			event.preventDefault();
			$("html, body").animate({
				scrollTop: $("html").offset().top
			}, 500, "easeInOutExpo");
			return false;
		});
		$(window).scroll(function(){
			var $win = $(window);
			if ($win.scrollTop() > 200) {
				$(".js-top").addClass("active");
			} else {
				$(".js-top").removeClass("active");
			}
		});
	};
	$(function(){
		goToTop();
	});
}());
</script>


</body>
</html>
